@[Link("libsensors")]
lib LibSensors
  type Feature = Void*

  enum FeatureType
    IN          = 0x00
    FAN         = 0x01
    TEMP        = 0x02
    POWER       = 0x03
    ENERGY      = 0x04
    CURR        = 0x05
    HUMIDITY    = 0x06
    MAX_MAIN
    VID         = 0x10
    INTRUSION   = 0x11
    MAX_OTHER
    BEEP_ENABLE = 0x18
    MAX
    UNKNOWN     = INT_MAX
  end
  enum SubfeatureType
    IN_INPUT               = FeatureType::IN << 8
    IN_MIN
    IN_MAX
    IN_LCRIT
    IN_CRIT
    IN_AVERAGE
    IN_LOWEST
    IN_HIGHEST
    IN_ALARM               = (FeatureType::IN << 8) | 0x80
    IN_MIN_ALARM
    IN_MAX_ALARM
    IN_BEEP
    IN_LCRIT_ALARM
    IN_CRIT_ALARM
    FAN_INPUT              = FeatureType::FAN << 8
    FAN_MIN
    FAN_MAX
    FAN_ALARM              = (FeatureType::FAN << 8) | 0x80
    FAN_FAULT
    FAN_DIV
    FAN_BEEP
    FAN_PULSES
    FAN_MIN_ALARM
    FAN_MAX_ALARM
    TEMP_INPUT             = FeatureType::TEMP << 8
    TEMP_MAX
    TEMP_MAX_HYST
    TEMP_MIN
    TEMP_CRIT
    TEMP_CRIT_HYST
    TEMP_LCRIT
    TEMP_EMERGENCY
    TEMP_EMERGENCY_HYST
    TEMP_LOWEST
    TEMP_HIGHEST
    TEMP_MIN_HYST
    TEMP_LCRIT_HYST
    TEMP_ALARM             = (FeatureType::TEMP << 8) | 0x80
    TEMP_MAX_ALARM
    TEMP_MIN_ALARM
    TEMP_CRIT_ALARM
    TEMP_FAULT
    TEMP_TYPE
    TEMP_OFFSET
    TEMP_BEEP
    TEMP_EMERGENCY_ALARM
    TEMP_LCRIT_ALARM
    POWER_AVERAGE          = FeatureType::POWER << 8
    POWER_AVERAGE_HIGHEST
    POWER_AVERAGE_LOWEST
    POWER_INPUT
    POWER_INPUT_HIGHEST
    POWER_INPUT_LOWEST
    POWER_CAP
    POWER_CAP_HYST
    POWER_MAX
    POWER_CRIT
    POWER_MIN
    POWER_LCRIT
    POWER_AVERAGE_INTERVAL = (FeatureType::POWER << 8) | 0x80
    POWER_ALARM
    POWER_CAP_ALARM
    POWER_MAX_ALARM
    POWER_CRIT_ALARM
    POWER_MIN_ALARM
    POWER_LCRIT_ALARM
    ENERGY_INPUT           = FeatureType::ENERGY << 8
    CURR_INPUT             = FeatureType::CURR << 8
    CURR_MIN
    CURR_MAX
    CURR_LCRIT
    CURR_CRIT
    CURR_AVERAGE
    CURR_LOWEST
    CURR_HIGHEST
    CURR_ALARM             = (FeatureType::CURR << 8) | 0x80
    CURR_MIN_ALARM
    CURR_MAX_ALARM
    CURR_BEEP
    CURR_LCRIT_ALARM
    CURR_CRIT_ALARM
    HUMIDITY_INPUT         = FeatureType::HUMIDITY << 8
    VID                    = FeatureType::VID << 8
    INTRUSION_ALARM        = FeatureType::INTRUSION << 8
    INTRUSION_BEEP
    BEEP_ENABLE            = FeatureType::BEEP_ENABLE << 8
    UNKNOWN                = INT_MAX
  end

  struct BusID
    type : LibC::Short
    nr : LibC::Short
  end

  struct ChipName
    prefix : Pointer(LibC::Char)
    bus : BusID
    addr : LibC::Int
    path : Pointer(LibC::Char)
  end

  struct Subfeature
    name : LibC::Char*
    number : LibC::Int
    type : SubfeatureType
    mapping : LibC::Int
    flags : LibC::UInt
  end

  # loads the configuration file and the detected chips list. If this returns a
  # value unequal to zero, you are in trouble; you can not assume anything will
  # be initialized properly. If you want to reload the configuration file, or
  # load a different configuration file, call LibSensors.cleanup below before
  # calling LibSensors.init again. This means you can't load multiple
  # configuration files at once by calling LibSensors.init multiple times.

  # The configuration file format is described in sensors.conf(5).

  # If FILE is NULL, the default configuration files are used (see the FILES
  # section in libsensors(3)). Most applications will want to do that.
  fun init = sensors_init(LibC::FILE*) : LibC::Int
  # cleans everything up: you can't access anything after this, until the
  # next LibSensors.init call!
  fun cleanup = sensors_cleanup : Void
  # is a string representing the version of libsensors
  fun version = libsensors_version : LibC::Char*
  # parses a chip name to the internal representation. Return 0 on
  # success, <0 on error. Make sure to call LibSensors.free_chip_name when
  # you're done with the data.
  fun parse_chip_name = sensors_parse_chip_name(orig_name : LibC::Char*,
                                                result : ChipName*) : LibC::Int
  # frees the memory that may have been allocated for the internal
  # representation of a chip name.  You only  have  to call this for chip names
  # which do not originate from libsensors itself (that is, chip names which
  # were generated by LibSensors.parse_chip_name).
  fun free_chip_name = sensors_free_chip_name(chip : ChipName) : Void
  # prints a chip name from its internal representation. Note that chip should
  # not contain wildcard values! Return the number of characters printed on
  # success (same as snprintf), <0 on error.
  fun snprintf_chip_name = sensors_snprintf_chip_name(str : LibC::Char*,
                                                      size : LibC::SizeT,
                                                      chip : ChipName*) : LibC::Int
  # returns the adapter name of a bus type, number pair, as used within the
  # LibSensors::ChipName structure. If it could not be found, it returns NULL.
  #
  # Adapters describe how a monitoring chip is hooked up to the system. This is
  # particularly  relevant  for  I2C/SMBus  sensor chips  (bus  type  "i2c"),
  # which must be accessed over an I2C/SMBus controller. Each such controller
  # has a different number, assigned by the system at initialization time,
  # so that they can be referenced individually.
  #
  # Super-I/O or CPU-embedded sensors, on the other hand, can be accessed
  # directly and technically don't use any  adapter.  They have only a bus
  # type but no bus number, and LibSensors.adapter_name will return a
  # generic adapter name for them.
  fun adapter_name = sensors_get_adapter_name(bus : BusID*) : LibC::Char*

  # # Chips and features enumeration

  # returns  all  detected chips that match a given chip name, one by one. If
  # no chip name is provided, all detected chips are returned. To start at the
  # beginning of the list, use 0 for nr; NULL is returned if we are at the end
  # of the list. Do not try to change these chip names, as they point to
  # internal structures!
  fun detected_chips = sensors_get_detected_chips(match : ChipName*, nr : LibC::Int*) : ChipName*
  # returns all main features of a specific chip. nr is an internally used
  # variable. Set it to zero to start at the begin of the list. If no more
  # features are found NULL is returned.  Do not try to change the returned
  # structure; you will corrupt internal data structures.
  fun features = sensors_get_features(name : ChipName*, nr : LibC::Int*) : Feature*
  # returns all subfeatures of a given main feature. nr is an internally used
  # variable. Set it to zero to start at the begin of the list. If no more
  # subfeatures are found NULL is returned.  Do not try to change the returned
  # structure; you will corrupt internal data structures.
  fun all_subfeatures = sensors_get_all_subfeatures(
    name : ChipName*,
    feature : Feature*,
    nr : LibC::Int*
  ) : Subfeature*
  # returns  the  subfeature of the given type for a given main feature, if it
  # exists, NULL otherwise. Do not try to change the returned structure; you
  # will corrupt internal data structures.
  fun subfeature = sensors_get_subfeature(name : ChipName*,
                                          feature : Feature*,
                                          type : SubfeatureType) : Subfeature*

  # Features access
  # looks up the label which belongs to this chip. Note that chip should not
  # contain wildcard values! The returned string is newly allocated (free it
  # yourself). On failure, NULL is returned.  If no label exists for this
  # feature, its name is returned itself.
  fun label = sensors_get_label(name : ChipName*,
                                feature : Feature*) : LibC::Char*
  # Reads the value of a subfeature of a certain chip. Note that chip should
  # not contain wildcard values! This function will return 0 on success, and
  # less than 0 on failure.
  fun value = sensors_get_value(name : ChipName*,
                                subfeat_nr : LibC::Int,
                                value : LibC::Double*) : LibC::Int
  # sets  the  value  of a subfeature of a certain chip. Note that chip
  # should not contain wildcard values! This function will return 0 on success,
  # and <0 on failure.
  fun set_value = sensors_set_value(name : ChipName*,
                                    subfeat_nr : LibC::Int,
                                    value : LibC::Double) : LibC::Int
  # executes all set statements for this particular chip. The chip may
  # contain wildcards! This function will return 0 on success, and <0 on
  # failure.
  fun do_chip_sets = sensors_do_chip_sets(name : ChipName*) : LibC::Int

  # include <sensors/error.h>

  # # Error decoding

  # returns a pointer to a string which describes the error. errnum may be
  # negative (the corresponding positive error is returned). You may not
  # modify the result!
  fun strerror = sensors_strerror(errnum : LibC::Int) : LibC::Char*

  # void (*sensors_parse_error) (err : LibC::Char*, lineno : LibC::Int)
  # void (*sensors_parse_error_wfn) (err : LibC::Char*,
  #                                  filename : LibC::Char*, lineno : LibC::Int);
  # void (*sensors_fatal_error) (proc : LibC::Char*, err : LibC::Char*);

end
